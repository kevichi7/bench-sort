// Generated by sortbench --init-plugin (v2 multi-type scaffold)
#include <algorithm>
#include <vector>
#include "../sortbench_plugin.h"

// Provide one or more type-specific entrypoints.
// Return algorithms via sortbench_get_algorithms_v2.

static void my_sort_i32(int* data, int n) { std::sort(data, data+n); }
static void my_sort_u32(unsigned int* data, int n) { std::sort(data, data+n); }
static void my_sort_i64(long long* data, int n) { std::sort(data, data+n); }
static void my_sort_u64(unsigned long long* data, int n) { std::sort(data, data+n); }
static void my_sort_f32(float* data, int n) { std::sort(data, data+n); }
static void my_sort_f64(double* data, int n) { std::sort(data, data+n); }

static const sortbench_algo_v2 k_algos[] = {
    {"my_sort", &my_sort_i32, &my_sort_u32, &my_sort_i64, &my_sort_u64, &my_sort_f32, &my_sort_f64},
};

extern "C" int sortbench_get_algorithms_v2(const sortbench_algo_v2** out_algos, int* out_count) {
    if (!out_algos || !out_count) return 0;
    *out_algos = k_algos;
    *out_count = (int)(sizeof(k_algos)/sizeof(k_algos[0]));
    return 1;
}

// Optional: also expose v1 (int-only) for older harnesses.
static const sortbench_algo_v1 k_algos_v1[] = {
    {"my_sort", &my_sort_i32},
};
extern "C" int sortbench_get_algorithms_v1(const sortbench_algo_v1** out_algos, int* out_count) {
    if (!out_algos || !out_count) return 0;
    *out_algos = k_algos_v1;
    *out_count = (int)(sizeof(k_algos_v1)/sizeof(k_algos_v1[0]));
    return 1;
}
